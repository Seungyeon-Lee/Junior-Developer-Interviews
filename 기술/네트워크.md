# 네트워크

### **1. http와 https**

**http는 무엇인가?**

**http와 https의 차이는 무엇인가? 둘의 장점과 단점?**

**SSL은 무엇인가?**

http는 hypertext transfer protocol로 www상에서 정보를 주고 받는 프로토콜이다.

웹 브라우저와 서버가 자원을 주고 받을 때 쓰는 통신 규악이라고 할 수 있다.

http는 텍스트를 교환한다. html과 같은 코드도 결국 텍스트이기 때문에 누군가 네트워크에서 이를 가로챈다면 내용이 노출될 가능성이 있다. 이를 해결하기 위해 만들어진 것이 https이다.

http에 secure socket을 붙여 만들어진 것이 https다.

따라서 둘의 가장 큰 차이는 보안 부분에 차이가 있다. http에 암호화와 인증, 완전성 보호를 더한 것이 https이다. http에 SSL(Secure Socket Layer)라는 인증서를 포함하여 만든 것이다. SSL은 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다. SSL 통신에 사용할 공개키를 클라이언트에 제공해준다.

http

장점 접속 도중 끊기더라도 처음부터 다시 시작할 필요가 없다.

단점 http는 클라이언트가 요청한 페이지를 암호화 되지 않은 상태로 주고 받을 수 있어서 클라이언트-서버의 네트워크에 침입해 중간에 정보를 가로챌 수 있다.

https

장점 보안성이 강하다. 클라이언트가 공개키를, 서버는 서버만 알수 있는 개인키를 사용한다.

단점 보안상 장점이 큰 대신에 통신과정에서 속도가 http보다 느리다.

### **2. OSI 7계층 & TCP/IP 4계층**

출처 : TCP/IP model vs OSI model

![https://blog.kakaocdn.net/dn/OVFpV/btqKC950MRT/Q7wEAKLrUBxrAPqzVayFFk/img.png](https://blog.kakaocdn.net/dn/OVFpV/btqKC950MRT/Q7wEAKLrUBxrAPqzVayFFk/img.png)

OSI 7계층은 통신이 일어나는 단계를 나눈 것이다. 특정 부분에 이상이 생기면 해당 단계만 수정할 수 있도록 나눠놓은 것이라고 할 수 있다.

물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 나눠져 있다.

물리는 리피터, 케이블 등을 의미한다.

데이터 링크는 브릿지, 스위치 등, 네트워크는 라우터와 IP를 전송은 TCP와 UDP를, 세션은 API와 소켓을, 표현은 SSL 등을, 응용은 HTTP, DNS를 의미한다.

TCP/IP 4계층은 OSI 7계층에서

물리-데이터링크를 묶어 네트워크 인터페이스 계층

네트워크는 인터넷 계층

전송은 전송 계층

세션, 표현, 응용 계층을 묶어 응용 계층으로 표현한 것이다.

각 계층은 통신이 일어나는 과정을 단계별로 파악할 수 있기 위해 나누어진 것으로 어떠한 과정에서 문제가 생겼을 때 계층별로 점검해나가며 문제를 해결할 수 있다.

### **3. 공개키 / 대칭키**

대칭키 방식 : 암호화와 복호화에 사용되는 키가 동일하다. 따라서 키를 비공개하는 방식이다. (EX. DES, AES)

공개키(비대칭키) 방식 : 암호화와 복호화에 사용되는 키가 상이하다. 하나의 키를 공개하는 방식을 취한다. (EX. RSA)

대칭키는 속도가 빠르다는 장점이 있지만, 키를 배송하는 도중 키가 노출될 우려(보안에 대한 우려)가 있다.

비대칭키는 대칭키에 비해 속도가 느리다는 단점이 있지만, 키를 배송하는 도중 키가 노출될 우려를 사전에 차단한다.

### **4. www.naver.com에 접속하면 일어나는 일**

참고자료 : [sophia2730.tistory.com/entry/DNS-주소창에-wwwnavercom을-치면-일어나는-일](https://sophia2730.tistory.com/entry/DNS-%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-wwwnavercom%EC%9D%84-%EC%B9%98%EB%A9%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC)

### **1. TCP & UDP**

**TCP와 UDP의 차이점은 무엇인가요?**

**TCP와 UDP 각각의 사용하는 서비스는 무엇인가요?**

TCP와 UDP는 실제 데이터 단위를 받기 위해 IP를 사용하는 프로토콜이다.

TCP의 경우에는 연결형 서비스이고, 높은 신뢰성 갖고있다. UDP보다 속도가 느립니다. 그러다보니 연속성보다 신뢰성있는 전송이 중요할 때 사용한다. http, email 등에 사용된다.

UDP는 여러 컴퓨터를 거치지 않고 데이터를 주고 받을 컴퓨터끼리 직접 연결할 때 사용한다. 따라서 UDP는 목적지에 도달하지 않을 수도 있는 특성이 있어서 비신뢰적이고 안정적이지 않다. 그러나 TCP보다 속도가 매우 빠르고 편해서 데이터 유실이 일어나도 상관이 없는 스트리밍이나 화면 전송에 사용된다.

### **2. 로드밸런싱**

**서버에 많은 부하가 일어날 때 필요한 것은 무엇인가요?**

**로드밸런서에 문제가 생기면 어떻게 해야하나요?**

**로드밸런싱 방식에는 어떤 것들이 있나요?**

로드밸런싱은 분산식 웹 서비스이다. 서버를 계층화 시켜서 여러 서버에 load를 balancing하는 것이다. 말 그대로 부하를 나누어서 웹 서버가 다운되지 않도록 만드는 목적을 가지고 있다.

로드 밸런서는 서버를 라운드 로빈, least connections, source 방식으로 선택한다.

CPU 스케줄링과 동일한 라운드 로빈 방식이 있고,

가장 적게 연결된 서버를 선택하는 방식,

그리소 사용자 IP를 해싱하여 분배하는 방식이 있다. Source 방식을 사용하면 특정 사용자가 항상 같은 서버로 연결되는 것이 보장된다.

로드 밸런서에 문제가 생기게 되면 서버에 큰 타격이 올 수 있으므로 로드 밸런서를 이중화 시켜 문제를 대비하여야 한다.

+ DNS를 라운드 로빈으로 설계하면 생길 수 있는 문제점?

[https://d2.naver.com/helloworld/284659](https://d2.naver.com/helloworld/284659)

### **3. 가상머신과 컨테이너의 차이**

**가상머신과 컨테이너의 차이점은 무엇인가요?**

**컨테이너의 장점과 단점?**

둘 모두 물리적 하드웨어의 필요성을 없애고, 애플리케이션을 어디서든 실행 가능하도록 만드는 데에 있다.

VM은 하이퍼바이저와 게스트 os가 모두 포함되어야 하기때문에 많은 용량을 차지 한다. 또한 부팅 시간에도 시간이 걸린다.

컨테이너는 어플리케이션을 실행, 배포하는 과정이 가볍기 때문에 더 많은 어플리케이션을 구동시킬 수 있다.

도커는 컨테이너를 관리하는 가상환경 플랫폼이다. 또한 도커는 프로세스이다. 단 하나의 타깃 프로세스를 실행하기 위한 파일들의 집합이다.

가상 머신은 하드웨어 기반의 여러 게스트 운영체제이다. 하이퍼바이저를 통해 에물레이션된다.

컨테이너는 애플리케이션 수준의 구성이며 커널 하나를 공유하는 여러 가상 환경을 에뮬레이션한다.

가상머신은 가상 머신에 구축된 애플리케이션을 실행할 때 메모리 사용량이 필요 이상으로 많아져 가상 머신이 호스트에 필요한 리소스를 모두 사용할 수 있다.

컨테이너는 기존 가상화와 달리 컨테이너화된 애플리케이션은 완전한 가상머신보다 리소스를 더 적게 사용하고 호스트 메모리에 가해지는 부담을 줄일 수 있도록 운영 체제 환경을 공유한다.

### **4. 3-way-hand-shake, 4-way-hand-shake**

**3-way-hand-shake와 4-way-hand-shake에 대해 설명해주세요.**

**왜 2-way로 충분할 것 같은데, 3-way를 사용하나요?**

**4-way-hand-shake중 두 번째 FIN이후 남은 패킷이 전송되기까지 기다리는 과정을 무엇이라 하나요?**

연결성립을 체크하기 위한 방식은 3way이고 연결해제를 체크하기 위한 방식은 4way이다.

3way

클라이언트는 서버에 SYN를 보낸다. 서버는 SYN를 받고 ACK를 보낸다. 클라이언트는 ACK를 받아서 확인한 ACK를 다시 보낸다.

4way

클라이언트는 서버에 FIN를 보낸다. 서버는 확인으로 ACK를 보낸다. 그리고 데이터를 모두 보낼 때까지 TIME_OUT이 된다. 데이터를 모두 보내면 서버는 클라이언트에 FIN 을 전송한다. 클라이언트는 FIN을 받고 확인한 ACK를 보낸다. 서버는 ACK를 받아서 소켓 연결을 close한다.

SYN은 synchronize sequence number

ACK는 acknowledgement

